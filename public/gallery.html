<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Gallery</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    canvas {
      display: block;
    }

    /* PCç”¨ã®æ“ä½œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¯å¸¸æ™‚éè¡¨ç¤ºï¼ˆå£ãƒ‘ãƒãƒ«ã¯åˆ¥ãªã®ã§OKï¼‰ */
    #info {
      display: none;
    }

    /* PCç”¨ã®æ“ä½œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºï¼‰ã€‚ã‚¿ãƒƒãƒç«¯æœ«ã§ã¯å¾Œæ®µã® @media ã§éè¡¨ç¤º */
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
      max-width: 300px;
      z-index: 1200;
    }

    #info strong {
      font-size: 16px;
      display: block;
      margin-bottom: 8px;
    }

    /* ã‚«ã‚¹ã‚¿ãƒ ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */
    #confirmOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #confirmOverlay.show {
      display: flex;
    }

    #confirmDialog {
      background: #1f2330;
      color: #e6e6e6;
      border-radius: 12px;
      padding: 18px 18px 14px;
      min-width: 300px;
      max-width: min(92vw, 520px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
      border: 1px solid rgba(255, 255, 255, .08);
    }

    #confirmTitle {
      font-weight: 700;
      margin-bottom: 10px;
      font-size: 16px;
    }

    #confirmDesc {
      font-size: 13px;
      color: #bfc7d5;
      margin-bottom: 14px;
      word-break: break-all;
    }

    #confirmDesc a {
      color: #8ab4ff;
      text-decoration: underline;
    }

    #confirmSub {
      white-space: pre-line;
    }

    #confirmActions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    #confirmActions button {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, .12);
      background: #2a2f3a;
      color: #e6e6e6;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
    }

    #confirmActions button.primary {
      background: #3b82f6;
      border-color: #3b82f6;
      color: white;
    }

    /* å¤–éƒ¨ç”»åƒãƒãƒ³ãƒ‰ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆä»»æ„ã§ /public/images/hand.png ã‚’é…ç½®ï¼‰ */
    #crosshairHandImg {
      position: absolute;
      left: 0;
      top: 0;
      width: 48px;
      height: 48px;
      display: none;
      image-rendering: auto;
    }

    /* ã‚¹ãƒãƒ›ç¸¦å‘ãæ™‚ã®å›è»¢æ¡ˆå†…ï¼ˆpointer:coarse ã§ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã«é™å®šï¼‰ */
    #rotateHint {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 2000;
      font-size: 16px;
      line-height: 1.6;
      pointer-events: none;
      /* æ¡ˆå†…ã¯è¡¨ç¤ºã®ã¿ã€‚èƒŒå¾Œã®æ“ä½œã¯è¨±å¯ */
    }

    #rotateHint strong {
      font-size: 20px;
      display: block;
      margin-bottom: 8px;
    }

    @media screen and (orientation: portrait) and (pointer: coarse) {
      #rotateHint {
        display: flex;
      }
    }

    /* === ãƒ¢ãƒã‚¤ãƒ«æ“ä½œUIï¼ˆpointer:coarse ã®ã¿è¡¨ç¤ºï¼‰=== */
    .hud {
      position: fixed;
      z-index: 1500;
      display: none;
    }

    .circle {
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      touch-action: none;
      position: relative;
    }

    .knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 56px;
      height: 56px;
      border-radius: 28px;
      background: rgba(255, 255, 255, 0.18);
      border: 1px solid rgba(255, 255, 255, 0.25);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    @media (pointer: coarse) {
      #joyLeft {
        display: block;
      }

      /* ã‚¿ãƒƒãƒç«¯æœ«ã§ã¯PCå‘ã‘æ“ä½œæ¡ˆå†…ã‚’éš ã™ */
      #info {
        display: none;
      }
    }
  </style>
</head>

<body>
  <!-- åå­—ã‚«ãƒ¼ã‚½ãƒ«ï¼ˆinfoã®å¤–ã«é…ç½®ã—ã¦å¸¸æ™‚è¡¨ç¤ºå¯èƒ½ã«ã™ã‚‹ï¼‰ -->
  <div id="crosshair"
    style="position:fixed;left:50%;top:50%;width:48px;height:48px;pointer-events:none;z-index:10;transform:translate(-50%,-50%);display:none;">
    <!-- é€šå¸¸ã®åå­— -->
    <svg id="crosshairCross" width="48" height="48" style="display:block;position:absolute;left:0;top:0;">
      <line x1="24" y1="12" x2="24" y2="36" stroke="#fff" stroke-width="2" />
      <line x1="12" y1="24" x2="36" y2="24" stroke="#fff" stroke-width="2" />
    </svg>
    <!-- ãƒ›ãƒãƒ¼æ™‚ã®æ‰‹ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆå¤–éƒ¨ç”»åƒï¼‰ã€‚æœªé…ç½®æ™‚ã¯ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã®ã¿è¡¨ç¤º -->
    <img id="crosshairHandImg" src="./images/hand@2x.png" alt="hand" />
  </div>

  <!-- ã‚«ã‚¹ã‚¿ãƒ ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–ã® confirm ç½®ãæ›ãˆç”¨ï¼‰ -->
  <div id="confirmOverlay" aria-hidden="true">
    <div id="confirmDialog" role="dialog" aria-modal="true" aria-labelledby="confirmTitle"
      aria-describedby="confirmDesc">
      <div id="confirmTitle">ã“ã®ä½œå“ã®ãƒšãƒ¼ã‚¸ã«ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ</div>
      <div id="confirmSub" style="font-size:12px;color:#9aa4b2;margin-bottom:8px;display:none;"></div>
      <div id="confirmDesc">ç§»å‹•å…ˆ: <a id="confirmUrl" href="#" target="_blank" rel="noopener"></a></div>
      <div id="confirmActions">
        <button id="confirmCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="confirmOk" class="primary">OK</button>
      </div>
    </div>
  </div>

  <!-- ç¸¦å‘ãæ™‚ã®å›è»¢æ¡ˆå†…ï¼ˆã‚¹ãƒãƒ›å‘ã‘ï¼‰ -->
  <div id="rotateHint">
    <div>
      <strong>ç«¯æœ«ã‚’æ¨ªå‘ãã«ã—ã¦ãã ã•ã„</strong>
      ãƒ©ãƒ³ãƒ‰ã‚¹ã‚±ãƒ¼ãƒ—ãƒ¢ãƒ¼ãƒ‰ã§ã‚ˆã‚Šå¿«é©ã«æ“ä½œã§ãã¾ã™ã€‚
    </div>
  </div>

  <div id="info">
    <strong>ğŸ¨ 3D ã‚®ãƒ£ãƒ©ãƒªãƒ¼</strong>
    <div style="margin-bottom: 8px;">
      <strong>ğŸ“ æ“ä½œæ–¹æ³•</strong><br>
      â€¢ ã‚¯ãƒªãƒƒã‚¯ã—ã¦å…¥å®¤<br>
      â€¢ ãƒã‚¦ã‚¹ç§»å‹•ã§è¦–ç‚¹å›è»¢
    </div>
    <div style="margin-bottom: 8px;">
      <strong>âŒ¨ï¸ ã‚­ãƒ¼æ“ä½œ</strong><br>
      â€¢ W / â†‘ : å‰é€²<br>
      â€¢ S / â†“ : å¾Œé€€<br>
      â€¢ A / â† : å·¦ç§»å‹•<br>
      â€¢ D / â†’ : å³ç§»å‹•<br>
      â€¢ E / ESC : é€€å®¤
    </div>
  </div>

  <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆå·¦ä¸‹:ç§»å‹• / å³ä¸‹:è¦–ç‚¹ï¼‰ -->
  <div id="joyLeft" class="hud" style="left:16px;bottom:16px;">
    <div class="circle">
      <div class="knob" id="joyLeftKnob"></div>
    </div>
  </div>


  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®åˆæœŸåŒ–
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // ç©ºè‰²
    scene.fog = new THREE.Fog(0x87ceeb, 0, 50);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2.5, 5); // çµµç”»ã®ä¸­å¿ƒã®é«˜ã•ã«åˆã‚ã›ã‚‹

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const isTouchDevice = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;

    // ãƒ©ã‚¤ãƒˆ
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.7);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    // ã‚·ãƒ£ãƒ‰ã‚¦ã®å“è³ªã¨è‡ªå·±ã‚·ãƒ£ãƒ‰ã‚¦æŠ‘åˆ¶
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.bias = -0.0002;
    directionalLight.shadow.normalBias = 0.02;
    const sc = directionalLight.shadow.camera;
    sc.near = 1; sc.far = 30;
    const dsz = 10; sc.left = -dsz; sc.right = dsz; sc.top = dsz; sc.bottom = -dsz;
    sc.updateProjectionMatrix();
    directionalLight.target.position.set(0, 0, 0);
    scene.add(directionalLight.target);

    // åºŠï¼ˆãƒ”ãƒ³ã‚¯ï¼‰: ãƒ¡ãƒƒã‚·ãƒ¥åˆ†å‰²ã‚’å¢—ã‚„ã—ã¦ã‚·ãƒ£ãƒ‰ã‚¦ã®ä¸‰è§’ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’è»½æ¸›
    const floorGeometry = new THREE.PlaneGeometry(15, 15, 12, 12);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0xFF0083, // ãƒ”ãƒ³ã‚¯ï¼ˆæŒ‡å®š: #FF0083ï¼‰
      roughness: 0.8,
      metalness: 0.2
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    // åºŠã¯è‡ªå·±å½±ã‚’å—ã‘å–ã‚‰ãªã„ï¼ˆä¸‰è§’ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆæŠ‘æ­¢ï¼‰
    floor.receiveShadow = false;
    scene.add(floor);

    // å¤©äº•ï¼ˆé»„è‰²ï¼‰
    const ceilingGeometry = new THREE.PlaneGeometry(15, 15);
    const ceilingMaterial = new THREE.MeshStandardMaterial({
      color: 0xFFFF00, // é»„è‰²
      roughness: 0.8,
      metalness: 0.1,
      side: THREE.DoubleSide
    });
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2; // ä¸‹å‘ã
    ceiling.position.y = 5;
    ceiling.receiveShadow = false; // å£ãƒ»å¤©äº•ã‚‚è‡ªå·±å½±å—ã‘å–ã‚Šã‚ªãƒ•ï¼ˆå¿…è¦æœ€å°é™ï¼‰
    scene.add(ceiling);

    // å£ã‚’ä½œæˆã™ã‚‹é–¢æ•°
    function createWall(width, height, position, rotation) {
      const wallGeometry = new THREE.BoxGeometry(width, height, 0.2);
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9
      });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.copy(position);
      if (rotation) wall.rotation.y = rotation;
      wall.castShadow = true;
      wall.receiveShadow = false; // å£ã®è‡ªå·±å½±å—ã‘å–ã‚Šã‚ªãƒ•
      scene.add(wall);
      return wall;
    }

    // å£ã‚’é…ç½®ï¼ˆ1/4ã‚µã‚¤ã‚ºã«ç¸®å°ï¼‰
    createWall(15, 5, new THREE.Vector3(0, 2.5, -7.5), 0);      // å¥¥
    createWall(15, 5, new THREE.Vector3(0, 2.5, 7.5), 0);       // æ‰‹å‰
    createWall(15, 5, new THREE.Vector3(-7.5, 2.5, 0), Math.PI / 2);  // å·¦
    createWall(15, 5, new THREE.Vector3(7.5, 2.5, 0), Math.PI / 2);   // å³

    // çµµç”»ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆã™ã‚‹é–¢æ•°
    function createArtwork(imageUrl, position, scale = 1) {
      const group = new THREE.Group();
      // ãƒ•ãƒ¬ãƒ¼ãƒ 
      const frameGeometry = new THREE.BoxGeometry(scale * 2.2, scale * 1.6, 0.1);
      const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 }); // é¡ç¸ã¯é»’
      const frame = new THREE.Mesh(frameGeometry, frameMaterial);
      group.add(frame);
      // çµµç”»
      const textureLoader = new THREE.TextureLoader();
      const artGeometry = new THREE.PlaneGeometry(scale * 2, scale * 1.5);
      const artMaterial = new THREE.MeshStandardMaterial({
        map: textureLoader.load(imageUrl, () => {
          console.log('Loaded:', imageUrl);
        }, undefined, (err) => {
          console.error('Failed to load:', imageUrl, err);
          artMaterial.color.set(0x666666);
        }),
        roughness: 0.8
      });
      const art = new THREE.Mesh(artGeometry, artMaterial);
      art.position.z = 0.06;
      group.add(art);
      group.position.copy(position);
      group.castShadow = true;

      // URLåŸ‹ã‚è¾¼ã¿ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ˆç¢ºå®Ÿã«è¨­å®šï¼‰
      group.userData = group.userData || {};
      group.userData.url = 'https://www.google.com';
      console.log('createArtwork: URLè¨­å®šå®Œäº†', group.userData.url);

      scene.add(group);
      return group;
    }

    // ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ãƒãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°ï¼ˆå£ã«èª¬æ˜æ–‡ã‚’è¡¨ç¤ºï¼‰
    function createTextPanel(text, position, rotation, width = 3, height = 2) {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');

      // èƒŒæ™¯
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // æ 
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 20;
      ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

      // ãƒ†ã‚­ã‚¹ãƒˆ
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 60px "MS Gothic", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ¨ æ“ä½œã‚¬ã‚¤ãƒ‰', canvas.width / 2, 120);

      ctx.font = '48px "MS Gothic", monospace';
      ctx.textAlign = 'left';
      const lines = text.split('\n');
      let y = 220;
      lines.forEach(line => {
        ctx.fillText(line, 80, y);
        y += 70;
      });

      const texture = new THREE.CanvasTexture(canvas);
      const panelGeometry = new THREE.PlaneGeometry(width, height);
      const panelMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        roughness: 0.9
      });
      const panel = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.position.copy(position);
      panel.rotation.y = rotation;
      panel.castShadow = true;
      scene.add(panel);

      return panel;
    }

    // ä½œå“ã®ç”»åƒã¨ãƒªãƒ³ã‚¯ã‚’ /public/images ã‹ã‚‰èª­ã¿è¾¼ã‚“ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ã«ã™ã‚‹
    async function chooseImage(candidates, fallback) {
      // Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§é †ã«å­˜åœ¨ãƒã‚§ãƒƒã‚¯ï¼ˆåŒä¸€ã‚ªãƒªã‚¸ãƒ³ãªã®ã§OKï¼‰ã€‚è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°fallbackã€‚
      for (const url of candidates) {
        const ok = await new Promise(resolve => {
          const img = new Image();
          img.onload = () => resolve(true);
          img.onerror = () => resolve(false);
          img.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¤ãƒ‘ã‚¹
        });
        if (ok) return url;
      }
      return fallback;
    }

    function normalizeLinkMeta(value, fallbackUrl) {
      if (!value) return { url: fallbackUrl };
      if (typeof value === 'string') return { url: value };
      const url = typeof value.url === 'string' ? value.url : fallbackUrl;
      const title = typeof value.title === 'string' ? value.title : undefined;
      const desc = typeof value.desc === 'string' ? value.desc : undefined;
      return { url, title, desc };
    }

    async function loadLinksConfig() {
      try {
        const res = await fetch('/images/links.json', { cache: 'no-store' });
        if (res.ok) return await res.json();
      } catch { }
      // æ—¢å®šã®ãƒªãƒ³ã‚¯
      return { back: 'https://www.google.com', left: 'https://www.google.com', right: 'https://www.google.com' };
    }

    async function initArtworks() {
      const [links, backImg, leftImg, rightImg] = await Promise.all([
        loadLinksConfig(),
        chooseImage(['/images/back.webp', '/images/back.png', '/images/back.jpg', '/images/back.jpeg'], 'https://picsum.photos/400/300?random=2'),
        chooseImage(['/images/left.webp', '/images/left.png', '/images/left.jpg', '/images/left.jpeg'], 'https://picsum.photos/400/300?random=4'),
        chooseImage(['/images/right.webp', '/images/right.png', '/images/right.jpg', '/images/right.jpeg'], 'https://picsum.photos/400/300?random=6')
      ]);

      // ãƒ¡ã‚¿ã‚’æ•´å½¢
      const backMeta = normalizeLinkMeta(links.back, 'https://www.google.com');
      const leftMeta = normalizeLinkMeta(links.left, 'https://www.google.com');
      const rightMeta = normalizeLinkMeta(links.right, 'https://www.google.com');

      // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ã®ã‚¿ã‚¤ãƒˆãƒ«è£œå®Œï¼ˆtitleãŒç„¡ã‘ã‚Œã°ï¼‰
      const nameFrom = (p) => {
        try { return p.split('/').pop().split('?')[0].replace(/\.[^.]+$/, ''); } catch { return undefined; }
      };
      backMeta.title = backMeta.title || nameFrom(backImg) || 'ä½œå“';
      leftMeta.title = leftMeta.title || nameFrom(leftImg) || 'ä½œå“';
      rightMeta.title = rightMeta.title || nameFrom(rightImg) || 'ä½œå“';

      // å¥¥ã®å£ï¼ˆä¸­å¤®ï¼‰
      const backArt = createArtwork(backImg, new THREE.Vector3(0, 2.5, -7.4), 1.5);
      backArt.userData.url = backMeta.url;
      backArt.userData.title = backMeta.title;
      backArt.userData.desc = backMeta.desc;
      console.log('å¥¥ã®å£ ç”»åƒ:', backImg, 'URL:', backArt.userData.url, 'TITLE:', backArt.userData.title);

      // å·¦ã®å£ï¼ˆä¸­å¤®ï¼‰
      const leftArt = createArtwork(leftImg, new THREE.Vector3(-7.4, 2.5, 0), 1.5);
      leftArt.rotation.y = Math.PI / 2;
      leftArt.userData.url = leftMeta.url;
      leftArt.userData.title = leftMeta.title;
      leftArt.userData.desc = leftMeta.desc;
      console.log('å·¦ã®å£ ç”»åƒ:', leftImg, 'URL:', leftArt.userData.url, 'TITLE:', leftArt.userData.title);

      // å³ã®å£ï¼ˆä¸­å¤®ï¼‰
      const rightArt = createArtwork(rightImg, new THREE.Vector3(7.4, 2.5, 0), 1.5);
      rightArt.rotation.y = -Math.PI / 2;
      rightArt.userData.url = rightMeta.url;
      rightArt.userData.title = rightMeta.title;
      rightArt.userData.desc = rightMeta.desc;
      console.log('å³ã®å£ ç”»åƒ:', rightImg, 'URL:', rightArt.userData.url, 'TITLE:', rightArt.userData.title);
    }
    // ãƒã‚¦ã‚¹å·¦ã‚¯ãƒªãƒƒã‚¯ã§æ³¨è¦–ä¸­ã®çµµã«é·ç§» & æ³¨è¦–ä¸­ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    let hasInteracted = false; // åˆæœŸãƒã‚¤ãƒ©ã‚¤ãƒˆæŠ‘åˆ¶ç”¨
    const raycaster = new THREE.Raycaster();
    let suppressClickUntil = 0; // UIæ“ä½œç›´å¾Œã®èª¤ã‚¿ãƒƒãƒ—æŠ‘åˆ¶
    function updateArtworkHighlight() {
      if (!hasInteracted) return; // åˆæœŸã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ãªã„
      // ã‚«ãƒ¡ãƒ©ä¸­å¤®ã‹ã‚‰Rayã‚’é£›ã°ã™
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const clickable = [];
      scene.traverse(obj => {
        if (obj.type === 'Group' && obj.userData.url) clickable.push(obj);
      });
      const intersects = raycaster.intersectObjects(clickable, true);
      // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å¯¾è±¡ã«ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹ã‹
      let hovering = false;
      if (intersects.length > 0) {
        let t = intersects[0].object;
        while (t && !t.userData?.url && t.parent) t = t.parent;
        hovering = !!(t && t.userData && t.userData.url);
      }

      // ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã‚’æ‰‹ã‚¢ã‚¤ã‚³ãƒ³ã«ãƒˆã‚°ãƒ«ï¼ˆæ¨™æº–ã‚«ãƒ¼ã‚½ãƒ«ã¯ãƒ­ãƒƒã‚¯ä¸­ã¯éè¡¨ç¤ºï¼‰
      const cross = document.getElementById('crosshairCross');
      const handImg = document.getElementById('crosshairHandImg');
      const useImg = handImg && handImg.complete && handImg.naturalWidth > 0;
      if (useImg && handImg) handImg.style.display = hovering ? 'block' : 'none';
      if (cross) cross.style.display = (hovering && useImg) ? 'none' : 'block';
    }
    // çµ±åˆã•ã‚ŒãŸã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    // ã‚«ã‚¹ã‚¿ãƒ ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
    function showConfirmNavigate(meta) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('confirmOverlay');
        const urlEl = document.getElementById('confirmUrl');
        const titleEl = document.getElementById('confirmTitle');
        const subEl = document.getElementById('confirmSub');
        const okBtn = document.getElementById('confirmOk');
        const cancelBtn = document.getElementById('confirmCancel');

        function cleanup() {
          overlay.classList.remove('show');
          overlay.setAttribute('aria-hidden', 'true');
          document.removeEventListener('keydown', onKey);
          okBtn.removeEventListener('click', onOk);
          cancelBtn.removeEventListener('click', onCancel);
        }
        function onOk() { cleanup(); resolve(true); }
        function onCancel() { cleanup(); resolve(false); }
        function onKey(e) {
          if (e.key === 'Escape') onCancel();
          if (e.key === 'Enter') onOk();
        }

        const titleText = (meta && meta.title) ? `ã€Œ${meta.title}ã€ã¸ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ` : 'ã“ã®ä½œå“ã®ãƒšãƒ¼ã‚¸ã«ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ';
        if (titleEl) titleEl.textContent = titleText;
        if (subEl) {
          if (meta && meta.desc) {
            subEl.textContent = meta.desc;
            subEl.style.display = 'block';
          } else {
            subEl.textContent = '';
            subEl.style.display = 'none';
          }
        }
        const url = (meta && meta.url) ? meta.url : 'https://www.google.com';
        urlEl.textContent = url;
        urlEl.href = url;
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
        cancelBtn.focus();
        document.addEventListener('keydown', onKey);
        okBtn.addEventListener('click', onOk);
        cancelBtn.addEventListener('click', onCancel);
      });
    }

    renderer.domElement.addEventListener('click', async (event) => {
      if (Date.now() < suppressClickUntil) { console.log('UIæ“ä½œå¾Œã®èª¤ã‚¿ãƒƒãƒ—æŠ‘æ­¢'); return; }
      console.log('=== ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚¯ãƒªãƒƒã‚¯æ¤œçŸ¥ ===');
      console.log('ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯çŠ¶æ…‹:', controls.isLocked);

      // ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€Œå…¥å®¤ã€ã®ã¿ï¼ˆãƒ­ãƒƒã‚¯è¦æ±‚ï¼‰ã§ã€ã“ã®ã‚¯ãƒªãƒƒã‚¯ã§ã¯é·ç§»ã—ãªã„
      if (!controls.isLocked) {
        if (!isTouchDevice) {
          console.log('ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯è¦æ±‚ä¸­...');
          event.stopPropagation();
          requestPointerLock();
          return;
        } else {
          console.log('ã‚¿ãƒƒãƒç«¯æœ«: ãƒ­ãƒƒã‚¯ç„¡ã—ã§ã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã‚’ç¶™ç¶š');
        }
      }

      // ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ä¸­ã®çµµç”»ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
      console.log('ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ä¸­ - çµµç”»ã‚¯ãƒªãƒƒã‚¯å‡¦ç†é–‹å§‹');

      // æ¯å›ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã—ã¦æœ€å‰é¢ã®ã‚¯ãƒªãƒƒã‚¯å¯¾è±¡ã‚’å–å¾—
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const clickable = [];
      scene.traverse(obj => {
        if (obj.type === 'Group' && obj.userData && obj.userData.url) clickable.push(obj);
      });
      const hits = raycaster.intersectObjects(clickable, true);
      if (hits.length === 0) {
        console.log('çµµç”»ã¨ã®äº¤å·®ãªã— - ã‚¯ãƒªãƒƒã‚¯ã—ãŸã®ã¯ç©ºé–“');
        return;
      }

      // äº¤å·®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¦ªã‚’è¾¿ã£ã¦Groupã‚’å–å¾—
      let target = hits[0].object;
      while (target && !target.userData?.url && target.parent) target = target.parent;
      const meta = target && target.userData ? {
        url: target.userData.url,
        title: target.userData.title,
        desc: target.userData.desc
      } : { url: 'https://www.google.com' };
      console.log('ãƒªãƒ³ã‚¯é·ç§»å€™è£œ:', meta);
      // æ¨™æº– confirm ã¯ä½¿ã‚ãšã€ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ç¢ºèª
      try { controls.unlock(); } catch { }
      const ok = await showConfirmNavigate(meta);
      if (ok) window.open(meta.url, '_blank');
    });

    // ç”»é¢ä¸Šã®ä»»æ„ä½ç½®ã‚¿ãƒƒãƒ—ã§é è·é›¢é¸æŠï¼ˆãƒ¢ãƒã‚¤ãƒ«å‘ã‘ï¼‰
    function findHitMetaAtNDC(nx, ny) {
      raycaster.setFromCamera({ x: nx, y: ny }, camera);
      const clickable = [];
      scene.traverse(obj => { if (obj.type === 'Group' && obj.userData?.url) clickable.push(obj); });
      const hits = raycaster.intersectObjects(clickable, true);
      if (hits.length === 0) return null;
      let target = hits[0].object;
      while (target && !target.userData?.url && target.parent) target = target.parent;
      if (!target || !target.userData?.url) return null;
      return { url: target.userData.url, title: target.userData.title, desc: target.userData.desc };
    }

    let tap = { id: null, x: 0, y: 0, moved: false, t0: 0 };
    const TAP_MS = 450;
    const TAP_PX = 14;
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (!isTouchDevice) return;
      const t = e.touches[0];
      tap = { id: t.identifier, x: t.clientX, y: t.clientY, moved: false, t0: Date.now() };
    }, { passive: true });
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (!isTouchDevice) return;
      const list = Array.from(e.touches);
      const t = list.find(tt => tt.identifier === tap.id);
      if (!t) return;
      if (Math.hypot(t.clientX - tap.x, t.clientY - tap.y) > TAP_PX) tap.moved = true;
    }, { passive: true });
    renderer.domElement.addEventListener('touchend', async (e) => {
      if (!isTouchDevice) return;
      // èª¤ã‚¿ãƒƒãƒ—æŠ‘æ­¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä¸­ã¯ç„¡è¦–
      if (Date.now() < suppressClickUntil) return;
      const dt = Date.now() - tap.t0;
      if (tap.moved || dt > TAP_MS) return;
      const cx = tap.x, cy = tap.y;
      // NDC ã«å¤‰æ›
      const rect = renderer.domElement.getBoundingClientRect();
      const nx = ((cx - rect.left) / rect.width) * 2 - 1;
      const ny = -(((cy - rect.top) / rect.height) * 2 - 1);
      const meta = findHitMetaAtNDC(nx, ny);
      if (!meta) return;
      try { controls.unlock(); } catch { }
      const ok = await showConfirmNavigate(meta);
      if (ok) window.open(meta.url, '_blank');
    }, { passive: true });

    // PointerLockControls (FPSé¢¨ã‚«ãƒ¡ãƒ©æ“ä½œ)
    // æ‰‹å‰ã®å£ã«æ“ä½œèª¬æ˜ãƒ‘ãƒãƒ«ã‚’é…ç½®
    const guideText = `W / â†‘ : å‰é€²
S / â†“ : å¾Œé€€
A / â† : å·¦ç§»å‹•
D / â†’ : å³ç§»å‹•
E / ESC : é€€å®¤`;
    createTextPanel(guideText, new THREE.Vector3(0, 2.5, 7.4), Math.PI, 4, 3);

    // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªä½œå“ã‚’åˆæœŸåŒ–
    initArtworks();

    // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆFPSé¢¨æ“ä½œï¼‰
    // ã‚¯ãƒªãƒƒã‚¯å¯¾è±¡ã¨ä¸€è‡´ã•ã›ã¦ãƒ­ãƒƒã‚¯æˆåŠŸç‡ã‚’ä¸Šã’ã‚‹ãŸã‚ canvas ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã™ã‚‹
    const controls = new PointerLockControls(camera, renderer.domElement);
    // ã‚«ãƒ¡ãƒ©ã‚’å†…åŒ…ã™ã‚‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚·ãƒ¼ãƒ³ã«è¿½åŠ ã—ã€åˆæœŸä½ç½®ã‚’è¨­å®š
    scene.add(controls.getObject());
    controls.getObject().position.set(0, 2.5, 5);

    // ãƒã‚¦ã‚¹æ„Ÿåº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚ˆã‚Šé…ãï¼‰
    controls.pointerSpeed = 0.3;

    // ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯å‡¦ç†ã‚’å¼·åŒ–ï¼ˆæœ€å°å®Ÿè£…ï¼‰
    async function tryLockLandscape() {
      // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ + ç”»é¢ã®å‘ãã‚’æ¨ªã«å›ºå®šã‚’è©¦ã¿ã‚‹ï¼ˆå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã®ã¿ï¼‰
      try {
        if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        }
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('landscape');
        }
      } catch (e) {
        console.warn('orientation lock failed (allowed on some browsers only):', e?.message || e);
      }
    }

    function requestPointerLock() {
      console.log('ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯è¦æ±‚é–‹å§‹');
      try {
        // ãƒ¢ãƒã‚¤ãƒ«ã§ã®æ¨ªå‘ãå›ºå®šã‚’è©¦ã™ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç„¡è¦–ï¼‰
        tryLockLandscape();
        controls.lock();
        console.log('controls.lock()ã‚’å®Ÿè¡Œã—ã¾ã—ãŸ');
      } catch (error) {
        console.error('ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ã«å¤±æ•—:', error);
      }
    }

    // ãƒ­ãƒƒã‚¯/ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ™‚ã®UI
    controls.addEventListener('lock', () => {
      hasInteracted = true; // æœ€åˆã®ãƒ­ãƒƒã‚¯ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆé–‹å§‹
      const cross = document.getElementById('crosshair');
      const info = document.getElementById('info');
      if (cross) cross.style.display = 'block';
      if (!isTouchDevice && info) info.style.display = 'none';
    });
    controls.addEventListener('unlock', () => {
      const cross = document.getElementById('crosshair');
      const info = document.getElementById('info');
      if (cross) cross.style.display = 'none';
      if (!isTouchDevice && info) info.style.display = 'block';
    });

    // ã‚­ãƒ¼å…¥åŠ›ã¨ç§»å‹•å‡¦ç†
    const moveSpeed = 0.12;
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      // Eã‚­ãƒ¼ã§ãƒ­ãƒƒã‚¯è§£é™¤
      if (e.code === 'KeyE' && controls.isLocked) controls.unlock();
    });
    document.addEventListener('keyup', (e) => { keys[e.code] = false; });
    // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒå…¥åŠ›ãŒã‚ã‚Œã°ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ¸ˆã¿ã¨ã¿ãªã™
    renderer.domElement.addEventListener('mousemove', () => { hasInteracted = true; });
    renderer.domElement.addEventListener('touchstart', () => { hasInteracted = true; }, { passive: true });

    // === ãƒ¢ãƒã‚¤ãƒ«æ“ä½œï¼ˆã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯/ãƒ«ãƒƒã‚¯ãƒ‘ãƒƒãƒ‰ï¼‰ ===
    let joyVec = { x: 0, y: 0 };
    const joyEl = document.getElementById('joyLeft');
    const joyKnob = document.getElementById('joyLeftKnob');
    const MAX_R = 50; // ã¤ã¾ã¿ã®å¯å‹•åŠå¾„
    const JOY_MOVE_FACTOR = 0.7; // å·¦ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®æ„Ÿåº¦ï¼ˆç§»å‹•å¯„ä¸ã‚’å¼±ã‚ã‚‹ï¼‰
    // UIç”¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒƒãƒIDï¼ˆã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ç­‰ï¼‰
    const activeUiTouchIds = new Set();

    function bindPad(container, knob, onChange) {
      if (!container) return;
      const circle = container.querySelector('.circle');
      let activeId = null;
      let center = { x: 0, y: 0 };
      function setKnob(dx, dy) {
        // ä¸­å¿ƒ(50%,50%)ã‹ã‚‰ã®ç›¸å¯¾ã‚ªãƒ•ã‚»ãƒƒãƒˆã§ä½ç½®æŒ‡å®šï¼ˆtransformã¯åˆæœŸã®centeråŸºæº–ã‚’ç¶­æŒï¼‰
        knob.style.left = `calc(50% + ${dx}px)`;
        knob.style.top = `calc(50% + ${dy}px)`;
      }
      function onStart(e) {
        const t = (e.touches ? e.touches[0] : e);
        const rect = circle.getBoundingClientRect();
        center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        activeId = t.identifier ?? 'mouse';
        if (t.identifier != null) activeUiTouchIds.add(activeId);
        onMove(e);
        e.preventDefault();
      }
      function onMove(e) {
        const list = e.touches ? Array.from(e.touches) : [e];
        const t = list.find(tt => (tt.identifier ?? 'mouse') === activeId);
        if (!t) return;
        const dx = t.clientX - center.x;
        const dy = t.clientY - center.y;
        const len = Math.hypot(dx, dy) || 1;
        const clamped = Math.min(len, MAX_R);
        const nx = (dx / len) * (clamped);
        const ny = (dy / len) * (clamped);
        // è¦‹ã‹ã‘ä½ç½®
        setKnob(nx, ny);
        // -1..1 ã®æ­£è¦åŒ–
        onChange({ x: nx / MAX_R, y: ny / MAX_R });
        suppressClickUntil = Date.now() + 300; // èª¤ã‚¿ãƒƒãƒ—æŠ‘æ­¢
        e.preventDefault();
      }
      function onEnd() {
        if (activeId != null) activeUiTouchIds.delete(activeId);
        activeId = null; setKnob(0, 0); onChange({ x: 0, y: 0 });
      }
      circle.addEventListener('touchstart', onStart, { passive: false });
      circle.addEventListener('touchmove', onMove, { passive: false });
      circle.addEventListener('touchend', onEnd);
      circle.addEventListener('touchcancel', onEnd);
    }

    bindPad(joyEl, joyKnob, v => { joyVec = v; hasInteracted = true; });

    // è¦–ç‚¹å›è»¢ï¼ˆPC: PointerLock / ãƒ¢ãƒã‚¤ãƒ«: ç”»é¢ãƒ‰ãƒ©ãƒƒã‚°ï¼‰
    let yaw = controls.getObject().rotation.y;
    let pitch = camera.rotation.x;
    const touchLookSpeed = 0.003; // ãƒ¢ãƒã‚¤ãƒ«ã®ãƒ‰ãƒ©ãƒƒã‚°æ„Ÿåº¦ï¼ˆpxã‚ãŸã‚Šãƒ©ã‚¸ã‚¢ãƒ³ï¼‰ã‚„ã‚„å¼·ã‚
    let lookTouchId = null;
    let lastLX = 0, lastLY = 0;
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ãƒ‰ãƒ©ãƒƒã‚°ã§è¦–ç‚¹ã‚’å›ã™ï¼ˆHUDæ“ä½œä¸­ã¯ç„¡åŠ¹ï¼‰
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (!isTouchDevice) return;
      // HUDä¸Šã§ã®é–‹å§‹ã¯ç„¡è¦–ï¼ˆã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯æ“ä½œï¼‰
      // ãŸã ã—åŒæ™‚æ“ä½œã®ãŸã‚ã€ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä¸­ã§ã‚‚åˆ¥æŒ‡ãŒã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šãªã‚‰è¦–ç‚¹ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½
      const candidates = (e.changedTouches && e.changedTouches.length ? Array.from(e.changedTouches) : Array.from(e.touches));
      const pick = candidates.find(t => !activeUiTouchIds.has(t.identifier) && !(document.elementFromPoint(t.clientX, t.clientY)?.closest?.('.hud')));
      if (!pick) return;
      lookTouchId = pick.identifier;
      lastLX = pick.clientX; lastLY = pick.clientY;
      hasInteracted = true;
    }, { passive: false });
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (!isTouchDevice) return;
      if (lookTouchId == null) return;
      const list = Array.from(e.touches);
      const t = list.find(tt => tt.identifier === lookTouchId);
      if (!t) return;
      const dx = t.clientX - lastLX;
      const dy = t.clientY - lastLY;
      lastLX = t.clientX; lastLY = t.clientY;
      // æ°´å¹³æ–¹å‘ï¼ˆyawï¼‰ã®ã¿å›è»¢ã€‚è¦‹ä¸Šã’/è¦‹ä¸‹ã’ã¯ã—ãªã„ã€‚
      yaw -= dx * touchLookSpeed;
      controls.getObject().rotation.y = yaw;
      suppressClickUntil = Date.now() + 250; // ãƒ‰ãƒ©ãƒƒã‚°ç›´å¾Œã®èª¤ã‚¿ãƒƒãƒ—æŠ‘æ­¢
      e.preventDefault();
    }, { passive: false });
    renderer.domElement.addEventListener('touchend', () => {
      lookTouchId = null;
    }, { passive: true });
    renderer.domElement.addEventListener('touchcancel', () => { lookTouchId = null; }, { passive: true });

    function updateMovement() {
      // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã¯ãƒ­ãƒƒã‚¯ä¸­ã®ã¿ç§»å‹•è¨±å¯ã€‚ãƒ¢ãƒã‚¤ãƒ«ã¯ãƒ­ãƒƒã‚¯ç„¡ã—ã§ã‚‚OKã€‚
      if (!controls.isLocked && !isTouchDevice) return;

      let moveForward = 0;
      let moveRight = 0;
      if (keys['KeyW'] || keys['ArrowUp']) moveForward += 1;
      if (keys['KeyS'] || keys['ArrowDown']) moveForward -= 1;
      if (keys['KeyD'] || keys['ArrowRight']) moveRight += 1;
      if (keys['KeyA'] || keys['ArrowLeft']) moveRight -= 1;

      // å·¦ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‹ã‚‰ã®ç§»å‹•ï¼ˆå‰å¾Œ: -y, å³å·¦: xï¼‰æ„Ÿåº¦ã‚’å¼±ã‚ã‚‹
      moveForward += (-joyVec.y) * JOY_MOVE_FACTOR;
      moveRight += (joyVec.x) * JOY_MOVE_FACTOR;

      if (moveForward !== 0) controls.moveForward(moveForward * moveSpeed);
      if (moveRight !== 0) controls.moveRight(moveRight * moveSpeed);

      // è¦–ç‚¹å›è»¢ã¯ãƒ¢ãƒã‚¤ãƒ«ã®ç”»é¢ãƒ‰ãƒ©ãƒƒã‚°ã§å‡¦ç†ï¼ˆã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„ï¼‰

      // å£å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—ï¼ˆ15x15ç›¸å½“ï¼‰
      const obj = controls.getObject();
      obj.position.x = Math.max(-7, Math.min(7, obj.position.x));
      obj.position.z = Math.max(-7, Math.min(7, obj.position.z));
    }
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      updateArtworkHighlight(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°ã‚’è¿½åŠ 
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>